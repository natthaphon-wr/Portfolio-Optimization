import numpy as np
import pandas as pd
import cvxpy as cp
import matplotlib.pyplot as plt
from deap import base, creator, tools, algorithms
import pygad

print("PyGAD version:", pygad.__version__)

# Select topN Liquidity from dataset
def data_top(path, n):
  df_all = pd.read_csv(path)
  df_sorted = df_all.sort_values(by='Liquidity', ascending=False)
  top_rows = df_sorted.head(n)
  return top_rows

# Create nparray of each feature from df
def df2nparray(df):
  Symbol = df['Symbol'].to_numpy()
  P = df['Lastest Price'].to_numpy()
  ER = df['Expected Return'].to_numpy()
  R = df['Risk'].to_numpy()
  L = df['Liquidity'].to_numpy()
  return Symbol, P, ER, R, L

def ga_solve(Symbol, P, ER, R, L, budget):


  return 0


# Read and select top data
def main_opt(path, n, budget):
  df = data_top(path, n)
  Symbol, P, ER, R, L = df2nparray(df)



  # result_df, optimized_return = solver_single(Symbol, P, ER, R, L, budget, multi=True, risk=0.075)
  # total_invest = (result_df['Price'] * result_df['NumberShares']).sum()
  # return result_df, total_invest, optimized_return

  return Symbol, P, ER, R, L


def main():
  path = 'Symbols24.csv'

  # Small problem
  Symbol, P, ER, R, L= main_opt(path, 12, 1000000)

main()

# --------------------------------------------------------------------------
# Generate example data (replace this with your actual data)
np.random.seed(42)
num_assets = 4
mean_returns = np.random.rand(num_assets)
cov_matrix = np.random.rand(num_assets, num_assets)

# Define the function to calculate portfolio returns and volatility
def calculate_portfolio_performance(weights, mean_returns, cov_matrix):
    portfolio_return = np.sum(weights * mean_returns)
    portfolio_stddev = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
    return portfolio_return, portfolio_stddev

# Define the fitness function for the genetic algorithm
def fitness_function(ga_instance, solution, solution_idx):
    weights = solution
    portfolio_return, portfolio_stddev = calculate_portfolio_performance(weights, mean_returns, cov_matrix)

    # Maximize Sharpe ratio (return divided by risk)
    return portfolio_return / portfolio_stddev

# Create an instance of the pygad.GA class
num_generations = 50
num_parents_mating = 2
sol_per_pop = 10
num_genes = num_assets
initial_population = np.random.rand(sol_per_pop, num_genes)

ga_instance = pygad.GA(num_generations=num_generations,
                       num_parents_mating=num_parents_mating,
                       fitness_func=fitness_function,
                       sol_per_pop=sol_per_pop,
                       num_genes=num_genes,
                       init_range_low=0.0,
                       init_range_high=1.0)

# Run the genetic algorithm
ga_instance.run()

# Get the best solution
best_solution, best_solution_fitness = ga_instance.best_solution()
best_weights = best_solution

# Print the results
print("Best Solution:", best_solution)
print("Best Solution Fitness:", best_solution_fitness)

# Calculate and print the final portfolio performance
final_portfolio_return, final_portfolio_stddev = calculate_portfolio_performance(best_weights, mean_returns, cov_matrix)
print("Final Portfolio Return:", final_portfolio_return)
print("Final Portfolio Standard Deviation:", final_portfolio_stddev)
